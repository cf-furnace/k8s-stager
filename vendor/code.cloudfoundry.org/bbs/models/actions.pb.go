// Code generated by protoc-gen-gogo.
// source: actions.proto
// DO NOT EDIT!

/*
	Package models is a generated protocol buffer package.

	It is generated from these files:
		actions.proto
		actual_lrp.proto
		actual_lrp_requests.proto
		cached_dependency.proto
		cells.proto
		desired_lrp.proto
		desired_lrp_requests.proto
		domain.proto
		environment_variables.proto
		error.proto
		evacuation.proto
		events.proto
		lrp_convergence_request.proto
		modification_tag.proto
		network.proto
		ping.proto
		security_group.proto
		task.proto
		task_requests.proto
		volume_mount.proto

	It has these top-level messages:
		Action
		DownloadAction
		UploadAction
		RunAction
		TimeoutAction
		EmitProgressAction
		TryAction
		ParallelAction
		SerialAction
		CodependentAction
		ResourceLimits
		ActualLRPGroup
		PortMapping
		ActualLRPKey
		ActualLRPInstanceKey
		ActualLRPNetInfo
		ActualLRP
		ActualLRPLifecycleResponse
		ActualLRPGroupsResponse
		ActualLRPGroupResponse
		ActualLRPGroupsRequest
		ActualLRPGroupsByProcessGuidRequest
		ActualLRPGroupByProcessGuidAndIndexRequest
		ClaimActualLRPRequest
		StartActualLRPRequest
		CrashActualLRPRequest
		FailActualLRPRequest
		RetireActualLRPRequest
		RemoveActualLRPRequest
		CachedDependency
		CellCapacity
		CellPresence
		Provider
		CellsResponse
		DesiredLRPSchedulingInfo
		DesiredLRPRunInfo
		ProtoRoutes
		DesiredLRPUpdate
		DesiredLRPKey
		DesiredLRPResource
		DesiredLRP
		DesiredLRPLifecycleResponse
		DesiredLRPsResponse
		DesiredLRPsRequest
		DesiredLRPResponse
		DesiredLRPSchedulingInfosResponse
		DesiredLRPByProcessGuidRequest
		DesireLRPRequest
		UpdateDesiredLRPRequest
		RemoveDesiredLRPRequest
		DomainsResponse
		UpsertDomainResponse
		UpsertDomainRequest
		EnvironmentVariable
		Error
		EvacuationResponse
		EvacuateClaimedActualLRPRequest
		EvacuateRunningActualLRPRequest
		EvacuateStoppedActualLRPRequest
		EvacuateCrashedActualLRPRequest
		RemoveEvacuatingActualLRPRequest
		RemoveEvacuatingActualLRPResponse
		ActualLRPCreatedEvent
		ActualLRPChangedEvent
		ActualLRPRemovedEvent
		DesiredLRPCreatedEvent
		DesiredLRPChangedEvent
		DesiredLRPRemovedEvent
		ActualLRPCrashedEvent
		ConvergeLRPsResponse
		ModificationTag
		Network
		PingResponse
		PortRange
		ICMPInfo
		SecurityGroupRule
		TaskDefinition
		Task
		TaskLifecycleResponse
		DesireTaskRequest
		StartTaskRequest
		StartTaskResponse
		FailTaskRequest
		TaskGuidRequest
		CompleteTaskRequest
		TaskCallbackResponse
		ConvergeTasksRequest
		ConvergeTasksResponse
		TasksRequest
		TasksResponse
		TaskByGuidRequest
		TaskResponse
		SharedDevice
		VolumeMount
		VolumePlacement
*/
package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import strings "strings"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
import sort "sort"
import strconv "strconv"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Action struct {
	DownloadAction     *DownloadAction     `protobuf:"bytes,1,opt,name=download_action,json=downloadAction" json:"download,omitempty"`
	UploadAction       *UploadAction       `protobuf:"bytes,2,opt,name=upload_action,json=uploadAction" json:"upload,omitempty"`
	RunAction          *RunAction          `protobuf:"bytes,3,opt,name=run_action,json=runAction" json:"run,omitempty"`
	TimeoutAction      *TimeoutAction      `protobuf:"bytes,4,opt,name=timeout_action,json=timeoutAction" json:"timeout,omitempty"`
	EmitProgressAction *EmitProgressAction `protobuf:"bytes,5,opt,name=emit_progress_action,json=emitProgressAction" json:"emit_progress,omitempty"`
	TryAction          *TryAction          `protobuf:"bytes,6,opt,name=try_action,json=tryAction" json:"try,omitempty"`
	ParallelAction     *ParallelAction     `protobuf:"bytes,7,opt,name=parallel_action,json=parallelAction" json:"parallel,omitempty"`
	SerialAction       *SerialAction       `protobuf:"bytes,8,opt,name=serial_action,json=serialAction" json:"serial,omitempty"`
	CodependentAction  *CodependentAction  `protobuf:"bytes,9,opt,name=codependent_action,json=codependentAction" json:"codependent,omitempty"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{0} }

func (m *Action) GetDownloadAction() *DownloadAction {
	if m != nil {
		return m.DownloadAction
	}
	return nil
}

func (m *Action) GetUploadAction() *UploadAction {
	if m != nil {
		return m.UploadAction
	}
	return nil
}

func (m *Action) GetRunAction() *RunAction {
	if m != nil {
		return m.RunAction
	}
	return nil
}

func (m *Action) GetTimeoutAction() *TimeoutAction {
	if m != nil {
		return m.TimeoutAction
	}
	return nil
}

func (m *Action) GetEmitProgressAction() *EmitProgressAction {
	if m != nil {
		return m.EmitProgressAction
	}
	return nil
}

func (m *Action) GetTryAction() *TryAction {
	if m != nil {
		return m.TryAction
	}
	return nil
}

func (m *Action) GetParallelAction() *ParallelAction {
	if m != nil {
		return m.ParallelAction
	}
	return nil
}

func (m *Action) GetSerialAction() *SerialAction {
	if m != nil {
		return m.SerialAction
	}
	return nil
}

func (m *Action) GetCodependentAction() *CodependentAction {
	if m != nil {
		return m.CodependentAction
	}
	return nil
}

type DownloadAction struct {
	Artifact          string `protobuf:"bytes,1,opt,name=artifact" json:"artifact,omitempty"`
	From              string `protobuf:"bytes,2,opt,name=from" json:"from"`
	To                string `protobuf:"bytes,3,opt,name=to" json:"to"`
	CacheKey          string `protobuf:"bytes,4,opt,name=cache_key,json=cacheKey" json:"cache_key"`
	LogSource         string `protobuf:"bytes,5,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
	User              string `protobuf:"bytes,6,opt,name=user" json:"user"`
	ChecksumAlgorithm string `protobuf:"bytes,7,opt,name=checksum_algorithm,json=checksumAlgorithm" json:"checksum_algorithm,omitempty"`
	ChecksumValue     string `protobuf:"bytes,8,opt,name=checksum_value,json=checksumValue" json:"checksum_value,omitempty"`
}

func (m *DownloadAction) Reset()                    { *m = DownloadAction{} }
func (*DownloadAction) ProtoMessage()               {}
func (*DownloadAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{1} }

func (m *DownloadAction) GetArtifact() string {
	if m != nil {
		return m.Artifact
	}
	return ""
}

func (m *DownloadAction) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *DownloadAction) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *DownloadAction) GetCacheKey() string {
	if m != nil {
		return m.CacheKey
	}
	return ""
}

func (m *DownloadAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *DownloadAction) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *DownloadAction) GetChecksumAlgorithm() string {
	if m != nil {
		return m.ChecksumAlgorithm
	}
	return ""
}

func (m *DownloadAction) GetChecksumValue() string {
	if m != nil {
		return m.ChecksumValue
	}
	return ""
}

type UploadAction struct {
	Artifact  string `protobuf:"bytes,1,opt,name=artifact" json:"artifact,omitempty"`
	From      string `protobuf:"bytes,2,opt,name=from" json:"from"`
	To        string `protobuf:"bytes,3,opt,name=to" json:"to"`
	LogSource string `protobuf:"bytes,4,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
	User      string `protobuf:"bytes,5,opt,name=user" json:"user"`
}

func (m *UploadAction) Reset()                    { *m = UploadAction{} }
func (*UploadAction) ProtoMessage()               {}
func (*UploadAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{2} }

func (m *UploadAction) GetArtifact() string {
	if m != nil {
		return m.Artifact
	}
	return ""
}

func (m *UploadAction) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *UploadAction) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *UploadAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *UploadAction) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

type RunAction struct {
	Path              string                 `protobuf:"bytes,1,opt,name=path" json:"path"`
	Args              []string               `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	Dir               string                 `protobuf:"bytes,3,opt,name=dir" json:"dir,omitempty"`
	Env               []*EnvironmentVariable `protobuf:"bytes,4,rep,name=env" json:"env,omitempty"`
	ResourceLimits    *ResourceLimits        `protobuf:"bytes,5,opt,name=resource_limits,json=resourceLimits" json:"resource_limits,omitempty"`
	User              string                 `protobuf:"bytes,6,opt,name=user" json:"user"`
	LogSource         string                 `protobuf:"bytes,7,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
	SuppressLogOutput bool                   `protobuf:"varint,8,opt,name=suppress_log_output,json=suppressLogOutput" json:"suppress_log_output"`
}

func (m *RunAction) Reset()                    { *m = RunAction{} }
func (*RunAction) ProtoMessage()               {}
func (*RunAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{3} }

func (m *RunAction) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RunAction) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *RunAction) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *RunAction) GetEnv() []*EnvironmentVariable {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *RunAction) GetResourceLimits() *ResourceLimits {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *RunAction) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *RunAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *RunAction) GetSuppressLogOutput() bool {
	if m != nil {
		return m.SuppressLogOutput
	}
	return false
}

type TimeoutAction struct {
	Action              *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	DeprecatedTimeoutNs int64   `protobuf:"varint,2,opt,name=deprecated_timeout_ns,json=deprecatedTimeoutNs" json:"timeout,omitempty"`
	LogSource           string  `protobuf:"bytes,3,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
	TimeoutMs           int64   `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs" json:"timeout_ms"`
}

func (m *TimeoutAction) Reset()                    { *m = TimeoutAction{} }
func (*TimeoutAction) ProtoMessage()               {}
func (*TimeoutAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{4} }

func (m *TimeoutAction) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TimeoutAction) GetDeprecatedTimeoutNs() int64 {
	if m != nil {
		return m.DeprecatedTimeoutNs
	}
	return 0
}

func (m *TimeoutAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

func (m *TimeoutAction) GetTimeoutMs() int64 {
	if m != nil {
		return m.TimeoutMs
	}
	return 0
}

type EmitProgressAction struct {
	Action               *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	StartMessage         string  `protobuf:"bytes,2,opt,name=start_message,json=startMessage" json:"start_message"`
	SuccessMessage       string  `protobuf:"bytes,3,opt,name=success_message,json=successMessage" json:"success_message"`
	FailureMessagePrefix string  `protobuf:"bytes,4,opt,name=failure_message_prefix,json=failureMessagePrefix" json:"failure_message_prefix"`
	LogSource            string  `protobuf:"bytes,5,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
}

func (m *EmitProgressAction) Reset()                    { *m = EmitProgressAction{} }
func (*EmitProgressAction) ProtoMessage()               {}
func (*EmitProgressAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{5} }

func (m *EmitProgressAction) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *EmitProgressAction) GetStartMessage() string {
	if m != nil {
		return m.StartMessage
	}
	return ""
}

func (m *EmitProgressAction) GetSuccessMessage() string {
	if m != nil {
		return m.SuccessMessage
	}
	return ""
}

func (m *EmitProgressAction) GetFailureMessagePrefix() string {
	if m != nil {
		return m.FailureMessagePrefix
	}
	return ""
}

func (m *EmitProgressAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

type TryAction struct {
	Action    *Action `protobuf:"bytes,1,opt,name=action" json:"action,omitempty"`
	LogSource string  `protobuf:"bytes,2,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
}

func (m *TryAction) Reset()                    { *m = TryAction{} }
func (*TryAction) ProtoMessage()               {}
func (*TryAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{6} }

func (m *TryAction) GetAction() *Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *TryAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

type ParallelAction struct {
	Actions   []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
	LogSource string    `protobuf:"bytes,2,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
}

func (m *ParallelAction) Reset()                    { *m = ParallelAction{} }
func (*ParallelAction) ProtoMessage()               {}
func (*ParallelAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{7} }

func (m *ParallelAction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *ParallelAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

type SerialAction struct {
	Actions   []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
	LogSource string    `protobuf:"bytes,2,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
}

func (m *SerialAction) Reset()                    { *m = SerialAction{} }
func (*SerialAction) ProtoMessage()               {}
func (*SerialAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{8} }

func (m *SerialAction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *SerialAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

type CodependentAction struct {
	Actions   []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
	LogSource string    `protobuf:"bytes,2,opt,name=log_source,json=logSource" json:"log_source,omitempty"`
}

func (m *CodependentAction) Reset()                    { *m = CodependentAction{} }
func (*CodependentAction) ProtoMessage()               {}
func (*CodependentAction) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{9} }

func (m *CodependentAction) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *CodependentAction) GetLogSource() string {
	if m != nil {
		return m.LogSource
	}
	return ""
}

type ResourceLimits struct {
	Nofile *uint64 `protobuf:"varint,1,opt,name=nofile" json:"nofile,omitempty"`
	Nproc  *uint64 `protobuf:"varint,2,opt,name=nproc" json:"nproc,omitempty"`
}

func (m *ResourceLimits) Reset()                    { *m = ResourceLimits{} }
func (*ResourceLimits) ProtoMessage()               {}
func (*ResourceLimits) Descriptor() ([]byte, []int) { return fileDescriptorActions, []int{10} }

func (m *ResourceLimits) GetNofile() uint64 {
	if m != nil && m.Nofile != nil {
		return *m.Nofile
	}
	return 0
}

func (m *ResourceLimits) GetNproc() uint64 {
	if m != nil && m.Nproc != nil {
		return *m.Nproc
	}
	return 0
}

func init() {
	proto.RegisterType((*Action)(nil), "models.Action")
	proto.RegisterType((*DownloadAction)(nil), "models.DownloadAction")
	proto.RegisterType((*UploadAction)(nil), "models.UploadAction")
	proto.RegisterType((*RunAction)(nil), "models.RunAction")
	proto.RegisterType((*TimeoutAction)(nil), "models.TimeoutAction")
	proto.RegisterType((*EmitProgressAction)(nil), "models.EmitProgressAction")
	proto.RegisterType((*TryAction)(nil), "models.TryAction")
	proto.RegisterType((*ParallelAction)(nil), "models.ParallelAction")
	proto.RegisterType((*SerialAction)(nil), "models.SerialAction")
	proto.RegisterType((*CodependentAction)(nil), "models.CodependentAction")
	proto.RegisterType((*ResourceLimits)(nil), "models.ResourceLimits")
}
func (this *Action) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Action)
	if !ok {
		that2, ok := that.(Action)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.DownloadAction.Equal(that1.DownloadAction) {
		return false
	}
	if !this.UploadAction.Equal(that1.UploadAction) {
		return false
	}
	if !this.RunAction.Equal(that1.RunAction) {
		return false
	}
	if !this.TimeoutAction.Equal(that1.TimeoutAction) {
		return false
	}
	if !this.EmitProgressAction.Equal(that1.EmitProgressAction) {
		return false
	}
	if !this.TryAction.Equal(that1.TryAction) {
		return false
	}
	if !this.ParallelAction.Equal(that1.ParallelAction) {
		return false
	}
	if !this.SerialAction.Equal(that1.SerialAction) {
		return false
	}
	if !this.CodependentAction.Equal(that1.CodependentAction) {
		return false
	}
	return true
}
func (this *DownloadAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DownloadAction)
	if !ok {
		that2, ok := that.(DownloadAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Artifact != that1.Artifact {
		return false
	}
	if this.From != that1.From {
		return false
	}
	if this.To != that1.To {
		return false
	}
	if this.CacheKey != that1.CacheKey {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.ChecksumAlgorithm != that1.ChecksumAlgorithm {
		return false
	}
	if this.ChecksumValue != that1.ChecksumValue {
		return false
	}
	return true
}
func (this *UploadAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*UploadAction)
	if !ok {
		that2, ok := that.(UploadAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Artifact != that1.Artifact {
		return false
	}
	if this.From != that1.From {
		return false
	}
	if this.To != that1.To {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.User != that1.User {
		return false
	}
	return true
}
func (this *RunAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RunAction)
	if !ok {
		that2, ok := that.(RunAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if len(this.Args) != len(that1.Args) {
		return false
	}
	for i := range this.Args {
		if this.Args[i] != that1.Args[i] {
			return false
		}
	}
	if this.Dir != that1.Dir {
		return false
	}
	if len(this.Env) != len(that1.Env) {
		return false
	}
	for i := range this.Env {
		if !this.Env[i].Equal(that1.Env[i]) {
			return false
		}
	}
	if !this.ResourceLimits.Equal(that1.ResourceLimits) {
		return false
	}
	if this.User != that1.User {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.SuppressLogOutput != that1.SuppressLogOutput {
		return false
	}
	return true
}
func (this *TimeoutAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TimeoutAction)
	if !ok {
		that2, ok := that.(TimeoutAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.DeprecatedTimeoutNs != that1.DeprecatedTimeoutNs {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	if this.TimeoutMs != that1.TimeoutMs {
		return false
	}
	return true
}
func (this *EmitProgressAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*EmitProgressAction)
	if !ok {
		that2, ok := that.(EmitProgressAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.StartMessage != that1.StartMessage {
		return false
	}
	if this.SuccessMessage != that1.SuccessMessage {
		return false
	}
	if this.FailureMessagePrefix != that1.FailureMessagePrefix {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	return true
}
func (this *TryAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*TryAction)
	if !ok {
		that2, ok := that.(TryAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Action.Equal(that1.Action) {
		return false
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	return true
}
func (this *ParallelAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ParallelAction)
	if !ok {
		that2, ok := that.(ParallelAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	return true
}
func (this *SerialAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SerialAction)
	if !ok {
		that2, ok := that.(SerialAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	return true
}
func (this *CodependentAction) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CodependentAction)
	if !ok {
		that2, ok := that.(CodependentAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Actions) != len(that1.Actions) {
		return false
	}
	for i := range this.Actions {
		if !this.Actions[i].Equal(that1.Actions[i]) {
			return false
		}
	}
	if this.LogSource != that1.LogSource {
		return false
	}
	return true
}
func (this *ResourceLimits) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ResourceLimits)
	if !ok {
		that2, ok := that.(ResourceLimits)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Nofile != nil && that1.Nofile != nil {
		if *this.Nofile != *that1.Nofile {
			return false
		}
	} else if this.Nofile != nil {
		return false
	} else if that1.Nofile != nil {
		return false
	}
	if this.Nproc != nil && that1.Nproc != nil {
		if *this.Nproc != *that1.Nproc {
			return false
		}
	} else if this.Nproc != nil {
		return false
	} else if that1.Nproc != nil {
		return false
	}
	return true
}
func (this *Action) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&models.Action{")
	if this.DownloadAction != nil {
		s = append(s, "DownloadAction: "+fmt.Sprintf("%#v", this.DownloadAction)+",\n")
	}
	if this.UploadAction != nil {
		s = append(s, "UploadAction: "+fmt.Sprintf("%#v", this.UploadAction)+",\n")
	}
	if this.RunAction != nil {
		s = append(s, "RunAction: "+fmt.Sprintf("%#v", this.RunAction)+",\n")
	}
	if this.TimeoutAction != nil {
		s = append(s, "TimeoutAction: "+fmt.Sprintf("%#v", this.TimeoutAction)+",\n")
	}
	if this.EmitProgressAction != nil {
		s = append(s, "EmitProgressAction: "+fmt.Sprintf("%#v", this.EmitProgressAction)+",\n")
	}
	if this.TryAction != nil {
		s = append(s, "TryAction: "+fmt.Sprintf("%#v", this.TryAction)+",\n")
	}
	if this.ParallelAction != nil {
		s = append(s, "ParallelAction: "+fmt.Sprintf("%#v", this.ParallelAction)+",\n")
	}
	if this.SerialAction != nil {
		s = append(s, "SerialAction: "+fmt.Sprintf("%#v", this.SerialAction)+",\n")
	}
	if this.CodependentAction != nil {
		s = append(s, "CodependentAction: "+fmt.Sprintf("%#v", this.CodependentAction)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DownloadAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&models.DownloadAction{")
	s = append(s, "Artifact: "+fmt.Sprintf("%#v", this.Artifact)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "CacheKey: "+fmt.Sprintf("%#v", this.CacheKey)+",\n")
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "ChecksumAlgorithm: "+fmt.Sprintf("%#v", this.ChecksumAlgorithm)+",\n")
	s = append(s, "ChecksumValue: "+fmt.Sprintf("%#v", this.ChecksumValue)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&models.UploadAction{")
	s = append(s, "Artifact: "+fmt.Sprintf("%#v", this.Artifact)+",\n")
	s = append(s, "From: "+fmt.Sprintf("%#v", this.From)+",\n")
	s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RunAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&models.RunAction{")
	s = append(s, "Path: "+fmt.Sprintf("%#v", this.Path)+",\n")
	if this.Args != nil {
		s = append(s, "Args: "+fmt.Sprintf("%#v", this.Args)+",\n")
	}
	s = append(s, "Dir: "+fmt.Sprintf("%#v", this.Dir)+",\n")
	if this.Env != nil {
		s = append(s, "Env: "+fmt.Sprintf("%#v", this.Env)+",\n")
	}
	if this.ResourceLimits != nil {
		s = append(s, "ResourceLimits: "+fmt.Sprintf("%#v", this.ResourceLimits)+",\n")
	}
	s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "SuppressLogOutput: "+fmt.Sprintf("%#v", this.SuppressLogOutput)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TimeoutAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&models.TimeoutAction{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "DeprecatedTimeoutNs: "+fmt.Sprintf("%#v", this.DeprecatedTimeoutNs)+",\n")
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "TimeoutMs: "+fmt.Sprintf("%#v", this.TimeoutMs)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EmitProgressAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&models.EmitProgressAction{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "StartMessage: "+fmt.Sprintf("%#v", this.StartMessage)+",\n")
	s = append(s, "SuccessMessage: "+fmt.Sprintf("%#v", this.SuccessMessage)+",\n")
	s = append(s, "FailureMessagePrefix: "+fmt.Sprintf("%#v", this.FailureMessagePrefix)+",\n")
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TryAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.TryAction{")
	if this.Action != nil {
		s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ParallelAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.ParallelAction{")
	if this.Actions != nil {
		s = append(s, "Actions: "+fmt.Sprintf("%#v", this.Actions)+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SerialAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.SerialAction{")
	if this.Actions != nil {
		s = append(s, "Actions: "+fmt.Sprintf("%#v", this.Actions)+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CodependentAction) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.CodependentAction{")
	if this.Actions != nil {
		s = append(s, "Actions: "+fmt.Sprintf("%#v", this.Actions)+",\n")
	}
	s = append(s, "LogSource: "+fmt.Sprintf("%#v", this.LogSource)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResourceLimits) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&models.ResourceLimits{")
	if this.Nofile != nil {
		s = append(s, "Nofile: "+valueToGoStringActions(this.Nofile, "uint64")+",\n")
	}
	if this.Nproc != nil {
		s = append(s, "Nproc: "+valueToGoStringActions(this.Nproc, "uint64")+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringActions(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringActions(m github_com_gogo_protobuf_proto.Message) string {
	e := github_com_gogo_protobuf_proto.GetUnsafeExtensionsMap(m)
	if e == nil {
		return "nil"
	}
	s := "proto.NewUnsafeXXX_InternalExtensions(map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "})"
	return s
}
func (m *Action) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Action) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadAction != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.DownloadAction.Size()))
		n1, err := m.DownloadAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UploadAction != nil {
		data[i] = 0x12
		i++
		i = encodeVarintActions(data, i, uint64(m.UploadAction.Size()))
		n2, err := m.UploadAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.RunAction != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintActions(data, i, uint64(m.RunAction.Size()))
		n3, err := m.RunAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.TimeoutAction != nil {
		data[i] = 0x22
		i++
		i = encodeVarintActions(data, i, uint64(m.TimeoutAction.Size()))
		n4, err := m.TimeoutAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.EmitProgressAction != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(m.EmitProgressAction.Size()))
		n5, err := m.EmitProgressAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.TryAction != nil {
		data[i] = 0x32
		i++
		i = encodeVarintActions(data, i, uint64(m.TryAction.Size()))
		n6, err := m.TryAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.ParallelAction != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintActions(data, i, uint64(m.ParallelAction.Size()))
		n7, err := m.ParallelAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.SerialAction != nil {
		data[i] = 0x42
		i++
		i = encodeVarintActions(data, i, uint64(m.SerialAction.Size()))
		n8, err := m.SerialAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.CodependentAction != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintActions(data, i, uint64(m.CodependentAction.Size()))
		n9, err := m.CodependentAction.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DownloadAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DownloadAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintActions(data, i, uint64(len(m.Artifact)))
	i += copy(data[i:], m.Artifact)
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.From)))
	i += copy(data[i:], m.From)
	data[i] = 0x1a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.To)))
	i += copy(data[i:], m.To)
	data[i] = 0x22
	i++
	i = encodeVarintActions(data, i, uint64(len(m.CacheKey)))
	i += copy(data[i:], m.CacheKey)
	data[i] = 0x2a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	data[i] = 0x32
	i++
	i = encodeVarintActions(data, i, uint64(len(m.User)))
	i += copy(data[i:], m.User)
	data[i] = 0x3a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.ChecksumAlgorithm)))
	i += copy(data[i:], m.ChecksumAlgorithm)
	data[i] = 0x42
	i++
	i = encodeVarintActions(data, i, uint64(len(m.ChecksumValue)))
	i += copy(data[i:], m.ChecksumValue)
	return i, nil
}

func (m *UploadAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UploadAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintActions(data, i, uint64(len(m.Artifact)))
	i += copy(data[i:], m.Artifact)
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.From)))
	i += copy(data[i:], m.From)
	data[i] = 0x1a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.To)))
	i += copy(data[i:], m.To)
	data[i] = 0x22
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	data[i] = 0x2a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.User)))
	i += copy(data[i:], m.User)
	return i, nil
}

func (m *RunAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RunAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintActions(data, i, uint64(len(m.Path)))
	i += copy(data[i:], m.Path)
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	data[i] = 0x1a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.Dir)))
	i += copy(data[i:], m.Dir)
	if len(m.Env) > 0 {
		for _, msg := range m.Env {
			data[i] = 0x22
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResourceLimits != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintActions(data, i, uint64(m.ResourceLimits.Size()))
		n10, err := m.ResourceLimits.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	data[i] = 0x32
	i++
	i = encodeVarintActions(data, i, uint64(len(m.User)))
	i += copy(data[i:], m.User)
	data[i] = 0x3a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	data[i] = 0x40
	i++
	if m.SuppressLogOutput {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	return i, nil
}

func (m *TimeoutAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TimeoutAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.Action.Size()))
		n11, err := m.Action.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	data[i] = 0x10
	i++
	i = encodeVarintActions(data, i, uint64(m.DeprecatedTimeoutNs))
	data[i] = 0x1a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	data[i] = 0x20
	i++
	i = encodeVarintActions(data, i, uint64(m.TimeoutMs))
	return i, nil
}

func (m *EmitProgressAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EmitProgressAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.Action.Size()))
		n12, err := m.Action.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.StartMessage)))
	i += copy(data[i:], m.StartMessage)
	data[i] = 0x1a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.SuccessMessage)))
	i += copy(data[i:], m.SuccessMessage)
	data[i] = 0x22
	i++
	i = encodeVarintActions(data, i, uint64(len(m.FailureMessagePrefix)))
	i += copy(data[i:], m.FailureMessagePrefix)
	data[i] = 0x2a
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	return i, nil
}

func (m *TryAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TryAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		data[i] = 0xa
		i++
		i = encodeVarintActions(data, i, uint64(m.Action.Size()))
		n13, err := m.Action.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	return i, nil
}

func (m *ParallelAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ParallelAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0xa
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	return i, nil
}

func (m *SerialAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SerialAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0xa
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	return i, nil
}

func (m *CodependentAction) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CodependentAction) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			data[i] = 0xa
			i++
			i = encodeVarintActions(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x12
	i++
	i = encodeVarintActions(data, i, uint64(len(m.LogSource)))
	i += copy(data[i:], m.LogSource)
	return i, nil
}

func (m *ResourceLimits) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceLimits) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Nofile != nil {
		data[i] = 0x8
		i++
		i = encodeVarintActions(data, i, uint64(*m.Nofile))
	}
	if m.Nproc != nil {
		data[i] = 0x10
		i++
		i = encodeVarintActions(data, i, uint64(*m.Nproc))
	}
	return i, nil
}

func encodeFixed64Actions(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Actions(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintActions(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Action) Size() (n int) {
	var l int
	_ = l
	if m.DownloadAction != nil {
		l = m.DownloadAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.UploadAction != nil {
		l = m.UploadAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.RunAction != nil {
		l = m.RunAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.TimeoutAction != nil {
		l = m.TimeoutAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.EmitProgressAction != nil {
		l = m.EmitProgressAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.TryAction != nil {
		l = m.TryAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.ParallelAction != nil {
		l = m.ParallelAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.SerialAction != nil {
		l = m.SerialAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	if m.CodependentAction != nil {
		l = m.CodependentAction.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	return n
}

func (m *DownloadAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Artifact)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.From)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.To)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.CacheKey)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.User)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.ChecksumAlgorithm)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.ChecksumValue)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *UploadAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Artifact)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.From)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.To)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.User)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *RunAction) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	n += 1 + l + sovActions(uint64(l))
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovActions(uint64(l))
		}
	}
	l = len(m.Dir)
	n += 1 + l + sovActions(uint64(l))
	if len(m.Env) > 0 {
		for _, e := range m.Env {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.User)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	n += 2
	return n
}

func (m *TimeoutAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	n += 1 + sovActions(uint64(m.DeprecatedTimeoutNs))
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	n += 1 + sovActions(uint64(m.TimeoutMs))
	return n
}

func (m *EmitProgressAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.StartMessage)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.SuccessMessage)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.FailureMessagePrefix)
	n += 1 + l + sovActions(uint64(l))
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *TryAction) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovActions(uint64(l))
	}
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *ParallelAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *SerialAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *CodependentAction) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovActions(uint64(l))
		}
	}
	l = len(m.LogSource)
	n += 1 + l + sovActions(uint64(l))
	return n
}

func (m *ResourceLimits) Size() (n int) {
	var l int
	_ = l
	if m.Nofile != nil {
		n += 1 + sovActions(uint64(*m.Nofile))
	}
	if m.Nproc != nil {
		n += 1 + sovActions(uint64(*m.Nproc))
	}
	return n
}

func sovActions(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozActions(x uint64) (n int) {
	return sovActions(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Action) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Action{`,
		`DownloadAction:` + strings.Replace(fmt.Sprintf("%v", this.DownloadAction), "DownloadAction", "DownloadAction", 1) + `,`,
		`UploadAction:` + strings.Replace(fmt.Sprintf("%v", this.UploadAction), "UploadAction", "UploadAction", 1) + `,`,
		`RunAction:` + strings.Replace(fmt.Sprintf("%v", this.RunAction), "RunAction", "RunAction", 1) + `,`,
		`TimeoutAction:` + strings.Replace(fmt.Sprintf("%v", this.TimeoutAction), "TimeoutAction", "TimeoutAction", 1) + `,`,
		`EmitProgressAction:` + strings.Replace(fmt.Sprintf("%v", this.EmitProgressAction), "EmitProgressAction", "EmitProgressAction", 1) + `,`,
		`TryAction:` + strings.Replace(fmt.Sprintf("%v", this.TryAction), "TryAction", "TryAction", 1) + `,`,
		`ParallelAction:` + strings.Replace(fmt.Sprintf("%v", this.ParallelAction), "ParallelAction", "ParallelAction", 1) + `,`,
		`SerialAction:` + strings.Replace(fmt.Sprintf("%v", this.SerialAction), "SerialAction", "SerialAction", 1) + `,`,
		`CodependentAction:` + strings.Replace(fmt.Sprintf("%v", this.CodependentAction), "CodependentAction", "CodependentAction", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DownloadAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DownloadAction{`,
		`Artifact:` + fmt.Sprintf("%v", this.Artifact) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`CacheKey:` + fmt.Sprintf("%v", this.CacheKey) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`ChecksumAlgorithm:` + fmt.Sprintf("%v", this.ChecksumAlgorithm) + `,`,
		`ChecksumValue:` + fmt.Sprintf("%v", this.ChecksumValue) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadAction{`,
		`Artifact:` + fmt.Sprintf("%v", this.Artifact) + `,`,
		`From:` + fmt.Sprintf("%v", this.From) + `,`,
		`To:` + fmt.Sprintf("%v", this.To) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RunAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RunAction{`,
		`Path:` + fmt.Sprintf("%v", this.Path) + `,`,
		`Args:` + fmt.Sprintf("%v", this.Args) + `,`,
		`Dir:` + fmt.Sprintf("%v", this.Dir) + `,`,
		`Env:` + strings.Replace(fmt.Sprintf("%v", this.Env), "EnvironmentVariable", "EnvironmentVariable", 1) + `,`,
		`ResourceLimits:` + strings.Replace(fmt.Sprintf("%v", this.ResourceLimits), "ResourceLimits", "ResourceLimits", 1) + `,`,
		`User:` + fmt.Sprintf("%v", this.User) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`SuppressLogOutput:` + fmt.Sprintf("%v", this.SuppressLogOutput) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TimeoutAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TimeoutAction{`,
		`Action:` + strings.Replace(fmt.Sprintf("%v", this.Action), "Action", "Action", 1) + `,`,
		`DeprecatedTimeoutNs:` + fmt.Sprintf("%v", this.DeprecatedTimeoutNs) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`TimeoutMs:` + fmt.Sprintf("%v", this.TimeoutMs) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EmitProgressAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EmitProgressAction{`,
		`Action:` + strings.Replace(fmt.Sprintf("%v", this.Action), "Action", "Action", 1) + `,`,
		`StartMessage:` + fmt.Sprintf("%v", this.StartMessage) + `,`,
		`SuccessMessage:` + fmt.Sprintf("%v", this.SuccessMessage) + `,`,
		`FailureMessagePrefix:` + fmt.Sprintf("%v", this.FailureMessagePrefix) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TryAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TryAction{`,
		`Action:` + strings.Replace(fmt.Sprintf("%v", this.Action), "Action", "Action", 1) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ParallelAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ParallelAction{`,
		`Actions:` + strings.Replace(fmt.Sprintf("%v", this.Actions), "Action", "Action", 1) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SerialAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SerialAction{`,
		`Actions:` + strings.Replace(fmt.Sprintf("%v", this.Actions), "Action", "Action", 1) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CodependentAction) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CodependentAction{`,
		`Actions:` + strings.Replace(fmt.Sprintf("%v", this.Actions), "Action", "Action", 1) + `,`,
		`LogSource:` + fmt.Sprintf("%v", this.LogSource) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResourceLimits) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResourceLimits{`,
		`Nofile:` + valueToStringActions(this.Nofile) + `,`,
		`Nproc:` + valueToStringActions(this.Nproc) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringActions(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (this *Action) GetValue() interface{} {
	if this.DownloadAction != nil {
		return this.DownloadAction
	}
	if this.UploadAction != nil {
		return this.UploadAction
	}
	if this.RunAction != nil {
		return this.RunAction
	}
	if this.TimeoutAction != nil {
		return this.TimeoutAction
	}
	if this.EmitProgressAction != nil {
		return this.EmitProgressAction
	}
	if this.TryAction != nil {
		return this.TryAction
	}
	if this.ParallelAction != nil {
		return this.ParallelAction
	}
	if this.SerialAction != nil {
		return this.SerialAction
	}
	if this.CodependentAction != nil {
		return this.CodependentAction
	}
	return nil
}

func (this *Action) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *DownloadAction:
		this.DownloadAction = vt
	case *UploadAction:
		this.UploadAction = vt
	case *RunAction:
		this.RunAction = vt
	case *TimeoutAction:
		this.TimeoutAction = vt
	case *EmitProgressAction:
		this.EmitProgressAction = vt
	case *TryAction:
		this.TryAction = vt
	case *ParallelAction:
		this.ParallelAction = vt
	case *SerialAction:
		this.SerialAction = vt
	case *CodependentAction:
		this.CodependentAction = vt
	default:
		return false
	}
	return true
}
func (m *Action) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadAction == nil {
				m.DownloadAction = &DownloadAction{}
			}
			if err := m.DownloadAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadAction == nil {
				m.UploadAction = &UploadAction{}
			}
			if err := m.UploadAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RunAction == nil {
				m.RunAction = &RunAction{}
			}
			if err := m.RunAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeoutAction == nil {
				m.TimeoutAction = &TimeoutAction{}
			}
			if err := m.TimeoutAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitProgressAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EmitProgressAction == nil {
				m.EmitProgressAction = &EmitProgressAction{}
			}
			if err := m.EmitProgressAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TryAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TryAction == nil {
				m.TryAction = &TryAction{}
			}
			if err := m.TryAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelAction == nil {
				m.ParallelAction = &ParallelAction{}
			}
			if err := m.ParallelAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SerialAction == nil {
				m.SerialAction = &SerialAction{}
			}
			if err := m.SerialAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodependentAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CodependentAction == nil {
				m.CodependentAction = &CodependentAction{}
			}
			if err := m.CodependentAction.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifact = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChecksumAlgorithm = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChecksumValue = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artifact", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artifact = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dir = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Env = append(m.Env, &EnvironmentVariable{})
			if err := m.Env[len(m.Env)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceLimits{}
			}
			if err := m.ResourceLimits.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuppressLogOutput", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SuppressLogOutput = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeoutAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeoutAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeoutAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeprecatedTimeoutNs", wireType)
			}
			m.DeprecatedTimeoutNs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DeprecatedTimeoutNs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutMs", wireType)
			}
			m.TimeoutMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimeoutMs |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmitProgressAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitProgressAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitProgressAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartMessage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuccessMessage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureMessagePrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureMessagePrefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TryAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TryAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TryAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &Action{}
			}
			if err := m.Action.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SerialAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SerialAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SerialAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CodependentAction) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CodependentAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CodependentAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActions
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceLimits) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActions
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nofile", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nofile = &v
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nproc", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActions
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nproc = &v
		default:
			iNdEx = preIndex
			skippy, err := skipActions(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActions
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipActions(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowActions
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActions
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthActions
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowActions
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipActions(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthActions = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowActions   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("actions.proto", fileDescriptorActions) }

var fileDescriptorActions = []byte{
	// 1035 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x56, 0x41, 0x6f, 0xdc, 0x44,
	0x14, 0xce, 0xae, 0x37, 0x9b, 0x78, 0xc8, 0x3a, 0xec, 0x74, 0x37, 0xdd, 0x26, 0x55, 0x52, 0x16,
	0x04, 0x41, 0x6a, 0x53, 0x84, 0x10, 0x87, 0x72, 0x40, 0x75, 0x41, 0x1c, 0x68, 0x69, 0xe4, 0x94,
	0x72, 0xb4, 0x1c, 0xef, 0xac, 0x63, 0xd5, 0xf6, 0x98, 0xb1, 0x9d, 0xb2, 0x9c, 0xf8, 0x07, 0x94,
	0x7f, 0xc0, 0x91, 0x9f, 0x92, 0x0b, 0x52, 0x8f, 0x9c, 0x0a, 0x2d, 0x17, 0xd4, 0x13, 0x3f, 0x81,
	0xe7, 0xe7, 0x99, 0xcd, 0x4c, 0x16, 0xa1, 0x86, 0x4a, 0x39, 0x58, 0xbb, 0x7e, 0xdf, 0xf7, 0xbe,
	0x37, 0xf3, 0xde, 0x9b, 0x37, 0x26, 0xbd, 0x20, 0x2c, 0x63, 0x9e, 0x15, 0x7b, 0xb9, 0xe0, 0x25,
	0xa7, 0xdd, 0x94, 0x4f, 0x58, 0x52, 0x6c, 0xde, 0x88, 0xe2, 0xf2, 0xa8, 0x3a, 0xdc, 0x0b, 0x79,
	0x7a, 0x33, 0xe2, 0x11, 0xbf, 0x89, 0xf0, 0x61, 0x35, 0xc5, 0x37, 0x7c, 0xc1, 0x7f, 0x8d, 0xdb,
	0xe6, 0x16, 0xcb, 0x8e, 0x63, 0xc1, 0xb3, 0x94, 0x65, 0xa5, 0x7f, 0x1c, 0x88, 0x38, 0x38, 0x4c,
	0x98, 0xd4, 0x1c, 0xff, 0xd4, 0x25, 0xdd, 0xdb, 0x18, 0x85, 0x7e, 0x43, 0xd6, 0x27, 0xfc, 0x71,
	0x96, 0xf0, 0x60, 0xe2, 0x37, 0x81, 0x47, 0xad, 0x6b, 0xad, 0xdd, 0x37, 0x3e, 0xdc, 0xd8, 0x6b,
	0x02, 0xef, 0x7d, 0x26, 0xe1, 0xc6, 0xc1, 0xdd, 0x78, 0xf9, 0x6c, 0x87, 0x2a, 0x97, 0xeb, 0x3c,
	0x8d, 0x4b, 0x96, 0xe6, 0xe5, 0xcc, 0x73, 0x26, 0x06, 0x8f, 0xde, 0x27, 0xbd, 0x2a, 0xd7, 0x65,
	0xdb, 0x28, 0x3b, 0x50, 0xb2, 0x5f, 0xe7, 0x9a, 0xe8, 0x00, 0x44, 0xdf, 0x6c, 0xe8, 0x9a, 0xe4,
	0x5a, 0xa5, 0x71, 0xe8, 0x1d, 0x42, 0x44, 0x95, 0x29, 0x35, 0x0b, 0xd5, 0xfa, 0x4a, 0xcd, 0xab,
	0x32, 0x29, 0xd5, 0x07, 0xa9, 0x1e, 0x10, 0x35, 0x1d, 0x5b, 0x28, 0x94, 0x1e, 0x10, 0xa7, 0x8c,
	0x53, 0xc6, 0xab, 0x52, 0x09, 0x75, 0x50, 0x68, 0xa8, 0x84, 0x1e, 0x34, 0xa8, 0x14, 0x1b, 0x82,
	0x58, 0x5f, 0x3a, 0x68, 0x82, 0xbd, 0x52, 0x67, 0xd1, 0x98, 0x0c, 0x18, 0x60, 0x3e, 0x24, 0x37,
	0x12, 0xac, 0x28, 0x94, 0xf4, 0x32, 0x4a, 0x6f, 0x2a, 0xe9, 0xcf, 0x81, 0xb3, 0x2f, 0x29, 0x52,
	0x7f, 0x0b, 0xf4, 0x2f, 0x1b, 0xbe, 0x5a, 0x14, 0xca, 0x16, 0x1c, 0xea, 0x24, 0x94, 0x62, 0xa6,
	0x02, 0x74, 0xcd, 0x24, 0x3c, 0x10, 0x33, 0x3d, 0x09, 0x40, 0xd4, 0x93, 0x50, 0x2a, 0xb4, 0xae,
	0x79, 0x1e, 0x88, 0x20, 0x49, 0x58, 0xa2, 0x94, 0x56, 0xcc, 0x9a, 0xef, 0x4b, 0x58, 0xaf, 0xb9,
	0x72, 0xd1, 0x6b, 0x9e, 0x1b, 0xbc, 0xba, 0xe6, 0x05, 0x83, 0x56, 0x9b, 0xcb, 0xae, 0x9a, 0x35,
	0x3f, 0x40, 0x50, 0xaf, 0x79, 0x43, 0xd7, 0x6b, 0x5e, 0x68, 0x1c, 0x1a, 0x12, 0x1a, 0x82, 0x6b,
	0xce, 0xb2, 0x49, 0xdd, 0xc7, 0x52, 0xd5, 0x46, 0xd5, 0x2b, 0x4a, 0xf5, 0xce, 0x29, 0x43, 0x4a,
	0x5f, 0x01, 0xe9, 0xa1, 0xe6, 0xa8, 0xe9, 0xf7, 0xc3, 0xb3, 0xec, 0x5b, 0x9d, 0x93, 0x9f, 0x77,
	0x5a, 0xe3, 0x27, 0x16, 0x71, 0xcc, 0x56, 0xa7, 0x1f, 0x93, 0xd5, 0x40, 0x94, 0xf1, 0x14, 0xc2,
	0xe2, 0xa1, 0xb0, 0xdd, 0xcd, 0x93, 0x67, 0x3b, 0x4b, 0x75, 0x32, 0x94, 0x5d, 0x53, 0x9e, 0x73,
	0xe9, 0x88, 0x74, 0xa6, 0x82, 0xa7, 0xd8, 0xf1, 0xb6, 0xdb, 0xa9, 0x7d, 0x3c, 0xb4, 0xd0, 0x01,
	0x69, 0x97, 0x1c, 0x7b, 0x57, 0xd9, 0xe1, 0x9d, 0xbe, 0x45, 0xec, 0x30, 0x08, 0x8f, 0x98, 0xff,
	0x88, 0xcd, 0xb0, 0x1f, 0x15, 0xb8, 0x8a, 0xe6, 0x2f, 0xd9, 0x8c, 0x7e, 0x42, 0x48, 0xc2, 0x23,
	0xbf, 0xe0, 0x95, 0x08, 0x19, 0x36, 0x96, 0xed, 0x5e, 0x95, 0x8b, 0x19, 0x9c, 0x22, 0x7a, 0xbd,
	0xc1, 0x7a, 0x80, 0xc6, 0x7a, 0x3d, 0x15, 0xa4, 0x15, 0xdb, 0x65, 0xbe, 0x9e, 0xda, 0x02, 0xc7,
	0x81, 0x42, 0x80, 0xf0, 0x51, 0x51, 0xa5, 0x7e, 0x90, 0x44, 0x5c, 0xc0, 0x8c, 0x49, 0xb1, 0x19,
	0x6c, 0xf7, 0x1d, 0x29, 0x7f, 0x75, 0x91, 0x61, 0xe4, 0x53, 0xa2, 0xb7, 0x15, 0x48, 0xbf, 0x20,
	0xce, 0xdc, 0xe5, 0x38, 0x48, 0x2a, 0x86, 0x6d, 0x60, 0xbb, 0xd7, 0xa4, 0xe0, 0xc8, 0x44, 0xf5,
	0x73, 0xa5, 0x90, 0x87, 0x35, 0x30, 0xfe, 0xb5, 0x45, 0xd6, 0xf4, 0x31, 0x71, 0x61, 0x05, 0x31,
	0xb3, 0xdd, 0xf9, 0x7f, 0xd9, 0x5e, 0x3e, 0x9b, 0xed, 0xf1, 0xef, 0x6d, 0x62, 0xcf, 0x07, 0x55,
	0xcd, 0xcb, 0x83, 0xf2, 0x48, 0x6e, 0x44, 0xf2, 0x6a, 0x0b, 0xa5, 0xa4, 0x13, 0x88, 0xa8, 0x80,
	0xe5, 0x5a, 0xbb, 0xb6, 0x87, 0xff, 0xe9, 0x7b, 0xc4, 0x9a, 0xc4, 0x42, 0xae, 0x74, 0x28, 0xd7,
	0xd2, 0x03, 0x93, 0xb6, 0x88, 0x9a, 0x41, 0x6f, 0x10, 0x0b, 0x46, 0x3f, 0x2c, 0xda, 0x82, 0x33,
	0xb2, 0x35, 0x9f, 0x3d, 0xa7, 0xb7, 0xc1, 0x43, 0x79, 0x19, 0x78, 0x35, 0x8f, 0x7e, 0x4a, 0xd6,
	0x61, 0xbc, 0xe0, 0xca, 0xfd, 0x24, 0x06, 0xa9, 0x42, 0x8e, 0xad, 0xf9, 0x2c, 0xf0, 0x24, 0x7c,
	0x17, 0x51, 0xcf, 0x11, 0xc6, 0xfb, 0x7f, 0x34, 0x97, 0x99, 0xc5, 0x95, 0xf3, 0x65, 0xf1, 0x23,
	0x72, 0xa9, 0xa8, 0xf2, 0x1c, 0xc7, 0x69, 0xcd, 0x85, 0x69, 0x9b, 0x57, 0x25, 0x76, 0xd2, 0xaa,
	0x8c, 0xd2, 0x57, 0x84, 0xbb, 0x3c, 0xba, 0x8f, 0xf0, 0xf8, 0x65, 0x8b, 0xf4, 0x8c, 0x09, 0x4e,
	0xdf, 0x25, 0x5d, 0xe3, 0x5a, 0x73, 0xd4, 0xb6, 0x1a, 0xdc, 0x93, 0x28, 0x8c, 0xae, 0x21, 0xcc,
	0x05, 0xc1, 0xc2, 0xa0, 0x64, 0x13, 0x5f, 0xdd, 0x11, 0x59, 0x81, 0x3d, 0x63, 0xb9, 0x5b, 0x72,
	0xdd, 0x8b, 0x97, 0xc1, 0xa8, 0xe5, 0x5d, 0x3a, 0xf5, 0x94, 0xc1, 0xbf, 0x2a, 0xce, 0xec, 0xde,
	0x3a, 0xdf, 0xee, 0xdf, 0x86, 0x31, 0x2f, 0x97, 0x90, 0x16, 0xd8, 0x80, 0x96, 0xdc, 0xb4, 0x2d,
	0xed, 0xf7, 0x8a, 0xf1, 0x8f, 0x6d, 0x42, 0x17, 0xef, 0x94, 0x57, 0xde, 0xf1, 0xfb, 0x30, 0xac,
	0x4b, 0x38, 0x22, 0x7e, 0x0a, 0xbe, 0x41, 0xc4, 0x8c, 0xd3, 0xb1, 0x86, 0xd0, 0xbd, 0x06, 0x81,
	0x9e, 0x5a, 0x2f, 0xaa, 0x30, 0xac, 0x6b, 0xa1, 0xc8, 0xfa, 0x91, 0x71, 0x24, 0xa8, 0xe8, 0xb7,
	0xc8, 0xc6, 0x34, 0x88, 0x93, 0x4a, 0x30, 0x45, 0x87, 0xeb, 0x8d, 0x4d, 0xe3, 0xef, 0x8c, 0xe1,
	0x36, 0x90, 0x1c, 0xe9, 0xb5, 0x8f, 0x8c, 0xd7, 0x1a, 0x74, 0xe3, 0x9c, 0xd8, 0xf3, 0x3b, 0xf0,
	0x95, 0xf3, 0x60, 0x46, 0x6c, 0x9f, 0x2f, 0xe2, 0x63, 0xe2, 0x98, 0x77, 0x25, 0xdd, 0x25, 0x2b,
	0xf2, 0x03, 0x0e, 0xe2, 0x5a, 0xff, 0x12, 0x57, 0xc1, 0xaf, 0x17, 0xb8, 0x22, 0x6b, 0xfa, 0x6d,
	0x7a, 0x51, 0x61, 0xbf, 0x27, 0xfd, 0x85, 0xeb, 0xf6, 0xa2, 0x62, 0x7f, 0x4b, 0x1c, 0x73, 0x16,
	0xd1, 0x0f, 0x48, 0x37, 0xe3, 0xd3, 0x38, 0x61, 0x58, 0xe2, 0x8e, 0x3b, 0x02, 0xa9, 0x56, 0xfd,
	0x59, 0xd1, 0x58, 0x35, 0x19, 0xc9, 0x83, 0x4e, 0x5e, 0xce, 0xe0, 0x53, 0x2b, 0xc4, 0xd8, 0x1d,
	0xf7, 0xb2, 0x74, 0x58, 0x47, 0xa3, 0xc6, 0x6f, 0x58, 0xee, 0xf5, 0xa7, 0xcf, 0xb7, 0x97, 0x7e,
	0x83, 0xe7, 0xef, 0xe7, 0xdb, 0xad, 0x1f, 0x5e, 0x6c, 0xb7, 0x7e, 0x81, 0xe7, 0x04, 0x9e, 0xa7,
	0xf0, 0xfc, 0x01, 0xcf, 0x5f, 0x2f, 0x00, 0x83, 0xdf, 0x27, 0x7f, 0x6e, 0x2f, 0xfd, 0x13, 0x00,
	0x00, 0xff, 0xff, 0xe4, 0xc0, 0x06, 0x40, 0xba, 0x0b, 0x00, 0x00,
}
